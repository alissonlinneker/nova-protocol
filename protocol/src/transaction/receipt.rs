//! Immutable transaction receipts for post-confirmation audit trails.
//!
//! A [`TransactionReceipt`] is generated after a transaction is included
//! in a finalized block. It captures the transaction outcome along with
//! block metadata, forming an immutable proof-of-execution that can be
//! verified independently.
//!
//! Receipt hashes use BLAKE3 (not SHA-256) because receipts are not
//! consensus-critical — they are derived artifacts. BLAKE3 gives us
//! faster hashing without any security trade-off for this use case.

use serde::{Deserialize, Serialize};

use super::builder::Transaction;
use super::types::{Amount, TransactionStatus};
use crate::crypto::hash::blake3_hash;

// ---------------------------------------------------------------------------
// BlockInfo
// ---------------------------------------------------------------------------

/// Metadata about the block that included a transaction.
///
/// Passed to [`TransactionReceipt::from_transaction`] at receipt creation
/// time. This is the minimal set of block data needed to anchor a receipt
/// to a specific point in the chain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockInfo {
    /// Block height (0-indexed).
    pub height: u64,
    /// Hex-encoded block hash.
    pub hash: String,
    /// Unix timestamp in milliseconds when the block was finalized.
    pub timestamp: u64,
}

// ---------------------------------------------------------------------------
// TransactionReceipt
// ---------------------------------------------------------------------------

/// An immutable receipt proving a transaction was included in a finalized block.
///
/// Receipts are generated by validators after block finalization and can be
/// served to light clients as proof-of-inclusion. The `receipt_hash` field
/// is a BLAKE3 digest of all other fields, allowing anyone to verify the
/// receipt has not been tampered with.
///
/// # Serialization
///
/// Receipts support both JSON (for APIs and human inspection) and bincode
/// (for compact storage and network transport).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct TransactionReceipt {
    /// The transaction ID (double-SHA-256 hex digest).
    pub tx_id: String,

    /// Height of the block that included this transaction.
    pub block_height: u64,

    /// Hex-encoded hash of the block that included this transaction.
    pub block_hash: String,

    /// Unix timestamp in milliseconds of the block.
    pub timestamp: u64,

    /// Sender's NOVA address.
    pub sender: String,

    /// Receiver's NOVA address.
    pub receiver: String,

    /// Transfer amount.
    pub amount: Amount,

    /// Final status of the transaction.
    pub status: TransactionStatus,

    /// Number of blocks confirmed on top of this transaction's block.
    /// Increases over time as the chain grows.
    pub confirmations: u64,

    /// BLAKE3 hash of all other receipt fields, hex-encoded.
    /// Proves the receipt has not been modified after creation.
    pub receipt_hash: String,
}

/// Intermediate struct for computing the receipt hash.
/// Includes every field except `receipt_hash` itself.
#[derive(Serialize)]
struct ReceiptHashData<'a> {
    tx_id: &'a str,
    block_height: u64,
    block_hash: &'a str,
    timestamp: u64,
    sender: &'a str,
    receiver: &'a str,
    amount: &'a Amount,
    status: &'a TransactionStatus,
    confirmations: u64,
}

impl TransactionReceipt {
    /// Creates a receipt from a confirmed transaction and its block metadata.
    ///
    /// The receipt captures a snapshot of the transaction's state at the time
    /// of block inclusion. The `confirmations` field starts at 1 (the block
    /// itself counts as the first confirmation).
    ///
    /// # Arguments
    ///
    /// * `tx` — The confirmed transaction.
    /// * `block_info` — Metadata about the block that included the transaction.
    /// * `status` — The execution result (typically `Confirmed` or `Failed`).
    pub fn from_transaction(
        tx: &Transaction,
        block_info: &BlockInfo,
        status: TransactionStatus,
    ) -> Self {
        let mut receipt = Self {
            tx_id: tx.id.clone(),
            block_height: block_info.height,
            block_hash: block_info.hash.clone(),
            timestamp: block_info.timestamp,
            sender: tx.sender.clone(),
            receiver: tx.receiver.clone(),
            amount: tx.amount.clone(),
            status,
            confirmations: 1,
            receipt_hash: String::new(), // computed below
        };

        receipt.receipt_hash = receipt.compute_hash();
        receipt
    }

    /// Computes the BLAKE3 hash of all receipt fields (excluding `receipt_hash`).
    ///
    /// Used both at creation time and for verification. If the returned hash
    /// does not match `self.receipt_hash`, the receipt has been tampered with.
    pub fn compute_hash(&self) -> String {
        let data = ReceiptHashData {
            tx_id: &self.tx_id,
            block_height: self.block_height,
            block_hash: &self.block_hash,
            timestamp: self.timestamp,
            sender: &self.sender,
            receiver: &self.receiver,
            amount: &self.amount,
            status: &self.status,
            confirmations: self.confirmations,
        };
        let bytes =
            bincode::serialize(&data).expect("receipt hash data serialization must not fail");
        hex::encode(blake3_hash(&bytes))
    }

    /// Verifies that the receipt hash matches its contents.
    ///
    /// Returns `true` if the receipt is authentic (no fields have been
    /// modified since creation).
    pub fn verify_integrity(&self) -> bool {
        self.receipt_hash == self.compute_hash()
    }

    /// Serializes the receipt to a JSON string.
    ///
    /// Used for API responses and human-readable logs.
    pub fn to_json(&self) -> String {
        serde_json::to_string_pretty(self).expect("receipt JSON serialization must not fail")
    }

    /// Deserializes a receipt from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }

    /// Serializes the receipt to compact binary (bincode).
    ///
    /// Used for persistent storage and network transport.
    pub fn to_binary(&self) -> Vec<u8> {
        bincode::serialize(self).expect("receipt bincode serialization must not fail")
    }

    /// Deserializes a receipt from binary (bincode).
    pub fn from_binary(data: &[u8]) -> Result<Self, bincode::Error> {
        bincode::deserialize(data)
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use crate::transaction::builder::TransactionBuilder;
    use crate::transaction::types::{Currency, TransactionType};

    fn sample_block_info() -> BlockInfo {
        BlockInfo {
            height: 42,
            hash: "aabbccdd".repeat(8),
            timestamp: 1_700_000_000_000,
        }
    }

    fn sample_tx() -> Transaction {
        TransactionBuilder::new(TransactionType::Transfer)
            .sender("nova:aaaa")
            .receiver("nova:bbbb")
            .amount(Amount::new(5_000, Currency::NOVA))
            .fee(100)
            .nonce(1)
            .timestamp(1_700_000_000_000)
            .build()
    }

    #[test]
    fn receipt_from_transaction() {
        let tx = sample_tx();
        let block_info = sample_block_info();
        let receipt =
            TransactionReceipt::from_transaction(&tx, &block_info, TransactionStatus::Confirmed);

        assert_eq!(receipt.tx_id, tx.id);
        assert_eq!(receipt.block_height, 42);
        assert_eq!(receipt.sender, tx.sender);
        assert_eq!(receipt.receiver, tx.receiver);
        assert_eq!(receipt.amount, tx.amount);
        assert_eq!(receipt.status, TransactionStatus::Confirmed);
        assert_eq!(receipt.confirmations, 1);
    }

    #[test]
    fn receipt_hash_is_deterministic() {
        let tx = sample_tx();
        let block_info = sample_block_info();

        let r1 =
            TransactionReceipt::from_transaction(&tx, &block_info, TransactionStatus::Confirmed);
        let r2 =
            TransactionReceipt::from_transaction(&tx, &block_info, TransactionStatus::Confirmed);

        assert_eq!(r1.receipt_hash, r2.receipt_hash);
    }

    #[test]
    fn receipt_hash_is_hex_encoded_64_chars() {
        let tx = sample_tx();
        let receipt = TransactionReceipt::from_transaction(
            &tx,
            &sample_block_info(),
            TransactionStatus::Confirmed,
        );

        // BLAKE3 produces 32 bytes = 64 hex chars.
        assert_eq!(receipt.receipt_hash.len(), 64);
        assert!(receipt.receipt_hash.chars().all(|c| c.is_ascii_hexdigit()));
    }

    #[test]
    fn receipt_integrity_verification() {
        let tx = sample_tx();
        let receipt = TransactionReceipt::from_transaction(
            &tx,
            &sample_block_info(),
            TransactionStatus::Confirmed,
        );

        assert!(receipt.verify_integrity());
    }

    #[test]
    fn tampered_receipt_fails_integrity() {
        let tx = sample_tx();
        let mut receipt = TransactionReceipt::from_transaction(
            &tx,
            &sample_block_info(),
            TransactionStatus::Confirmed,
        );

        receipt.confirmations = 9999;
        assert!(!receipt.verify_integrity());
    }

    #[test]
    fn receipt_json_roundtrip() {
        let tx = sample_tx();
        let receipt = TransactionReceipt::from_transaction(
            &tx,
            &sample_block_info(),
            TransactionStatus::Confirmed,
        );

        let json = receipt.to_json();
        let recovered = TransactionReceipt::from_json(&json).unwrap();
        assert_eq!(receipt, recovered);
    }

    #[test]
    fn receipt_binary_roundtrip() {
        let tx = sample_tx();
        let receipt = TransactionReceipt::from_transaction(
            &tx,
            &sample_block_info(),
            TransactionStatus::Confirmed,
        );

        let bytes = receipt.to_binary();
        let recovered = TransactionReceipt::from_binary(&bytes).unwrap();
        assert_eq!(receipt, recovered);
    }

    #[test]
    fn different_status_different_hash() {
        let tx = sample_tx();
        let block_info = sample_block_info();

        let confirmed =
            TransactionReceipt::from_transaction(&tx, &block_info, TransactionStatus::Confirmed);
        let failed =
            TransactionReceipt::from_transaction(&tx, &block_info, TransactionStatus::Failed);

        assert_ne!(confirmed.receipt_hash, failed.receipt_hash);
    }

    #[test]
    fn json_output_is_readable() {
        let tx = sample_tx();
        let receipt = TransactionReceipt::from_transaction(
            &tx,
            &sample_block_info(),
            TransactionStatus::Confirmed,
        );

        let json = receipt.to_json();
        assert!(json.contains("tx_id"));
        assert!(json.contains("block_height"));
        assert!(json.contains("receipt_hash"));
    }
}
